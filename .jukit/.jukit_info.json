{"cmd": "import os\nimport numpy as np\nimport cv2\nimport torch\nimport faiss\nfrom transformers import ViTImageProcessor, ViTModel\nfrom sklearn.model_selection import train_test_split\nfrom tqdm import tqdm\nimport pickle\nclass ViTFaceRecognition:\n    def __init__(self, src_dir='data/train_img/'):\n        self.src_dir = src_dir\n        self.device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n        \n        # Load pretrained ViT (không dùng classification head)\n        self.processor = ViTImageProcessor.from_pretrained('google/vit-base-patch16-224')\n        self.model = ViTModel.from_pretrained('google/vit-base-patch16-224').to(self.device)\n        self.model.eval()\n        \n        # Faiss index\n        self.index = None\n        self.labels = []\n        self.class_to_id = {}\n        \n    def load_data(self, train = True, faiss_index_path = None, metadata_path = None):\n        \"\"\"Load images and labels from directory structure: src_dir/class_name/image.jpg\"\"\"\n        if train:\n            self.class_to_id = {cls: idx for idx, cls in enumerate(os.listdir(self.src_dir))}\n            self.labels = []\n            images = []\n            \n            for cls in os.listdir(self.src_dir):\n                cls_dir = os.path.join(self.src_dir, cls)\n                for img_name in tqdm(os.listdir(cls_dir), desc=f\"Loading {cls}\"):\n                    img_path = os.path.join(cls_dir, img_name)\n                    img = cv2.cvtColor(cv2.imread(img_path), cv2.COLOR_BGR2RGB)\n                    images.append(img)\n                    self.labels.append(self.class_to_id[cls])\n            \n            return images, np.array(self.labels)\n        else:\n            # Load faiss index and metadata\n            self.index = faiss.read_index(faiss_index_path)\n            with open(metadata_path, 'rb') as f:\n                metadata = pickle.load(f)\n                self.labels = metadata['labels']\n                self.class_to_id = metadata['label_to_id']\n            return None, None\n\n    def extract_features(self, images):\n        \"\"\"Extract ViT embeddings (CLS token)\"\"\"\n        inputs = self.processor(images=images, return_tensors=\"pt\", padding=True).to(self.device)\n        with torch.no_grad():\n            outputs = self.model(**inputs)\n        return outputs.last_hidden_state[:, 0, :].cpu().numpy()  # CLS token\n\n    def build_and_save_faiss_index(self, features, save_path=None): # save_path = faiss index path\n        \"\"\"Create FAISS index for fast similarity search\"\"\"\n        dim = features.shape[1]\n        self.index = faiss.IndexFlatL2(dim)  # L2 distance\n        self.index.add(features.astype('float32'))\n\n        #Save index and metadata\n        faiss.write_index(self.index, save_path + '.faiss') # Save index\n\n        with open(f\"{save_path}_metadata.pkl\", \"wb\") as f:\n            pickle.dump({\"labels\": self.labels, \"label_to_id\": self.class_to_id}, f) # Save metadata, metadata include labels and mapping from label to id , or we can call it class_to_id \n\n    def add_new_user(self, img_paths, user_name, faiss_index_path, metadata_path):\n        \"\"\"Add new user embedding to Faiss index\"\"\"\n        if self.index is None: \n            self.index, self.labels, self.class_to_id = self.load_data(train = False, faiss_index_path = faiss_index_path, metadata_path = metadata_path)\n\n        if user_name not in self.class_to_id:\n            self.class_to_id[user_name] = len(self.class_to_id)\n\n        for img_path in img_paths:\n            img = cv2.imread(img_path)\n            img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n            embedding = self.extract_features([img])\n            self.index.add(embedding.astype('float32'))\n        self.labels.append(self.class_to_id[user_name])\n        print(f\"Added user: {user_name}\")\n        # Save updated Index and metadata\n        faiss.write_index(self.index, faiss_index_path)\n        with open(metadata_path, \"wb\") as f:\n            pickle.dump({\"labels\": self.labels, \"label_to_id\": self.class_to_id}, f)\n\n\n    def recognize_face_1(self, query_img_path, threshold=0.9):\n        \"\"\"Recognize face using FAISS search\"\"\"\n        img = cv2.cvtColor(cv2.imread(query_img_path), cv2.COLOR_BGR2RGB)\n        query_embed = self.extract_features([img])\n        \n        D, I = self.index.search(query_embed.astype('float32'), k=1)\n        distance = D[0][0]\n        pred_id = self.labels[I[0][0]]\n        \n        # Convert distance to cosine similarity (assuming embeddings are normalized)\n        similarity = 1 - distance / 2  \n        if similarity > threshold:\n            user_name = [k for k, v in self.class_to_id.items() if v == pred_id][0]\n            return user_name, similarity\n        else:\n            return \"Unknown\", similarity\n    # recognize_face for list of images\n\n    def recognize_face_2(self, query_img_list, threshold=0.9):\n        \"\"\"Recognize face using FAISS search\"\"\"\n        #\n        results = []\n        for image in query_img_list:\n            image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n            query_embed = self.extract_features([image])\n\n            D, I = self.index.search(query_embed.astype('float32'), k=1)\n            distance = D[0][0]\n            pred_id = self.labels[I[0][0]]\n            # Convert distance to cosine similarity (assuming embeddings are normalized)\n            similarity = 1 - distance / 2  \n            if similarity > threshold:\n                user_name = [k for k, v in self.class_to_id.items() if v == pred_id][0]\n                results.append((user_name, pred_id, similarity))\n            else:\n                results.append((\"Unknown\", pred_id, similarity))\n\n        return results\n            \n# Usage Example\nif __name__ == \"__main__\":\n    vit = ViTFaceRecognition(src_dir= os.path.join('train_img'))\n    images, labels = vit.load_data(train=True, faiss_index_path='faiss_index.faiss', metadata_path='faiss_index_metadata.pkl')\n    #features = vit.extract_features(images)\n    #vit.build_and_save_faiss_index(features, save_path='faiss_index') #if file is not exist, you have to train index for images\n    # Test recognition\n    result, score = vit.recognize_face_1('train_img/Long/cropped_face_10.jpg')\n    print(f\"Recognized: {result} (Score: {score:.2f})\")\n\n    # Test new User\n#    usr_dir = 'train_img/Michael_Powell'\n#    paths_new_user = os.listdir(usr_dir)\n#    usr_paths = [os.path.join(usr_dir, path) for path in paths_new_user]\n#    vit.add_new_user(usr_paths, 'Michael_Powell', faiss_index_path='faiss_index.faiss', metadata_path='faiss_index_metadata.pkl')\n    # Test recognition after adding new user\n", "outhist_cell": "NONE", "outhist_title": "BMQDp0hdjw", "is_md": 0, "cmd_opts": " --cell_id=QmmjrfLpJ4 -s", "import_complete": 1, "terminal": "kitty"}